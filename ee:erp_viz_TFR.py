# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18TeETVGE5wsXCDNQOGph1LKuo7pVevJg
"""

!pip install mne

import mne
import matplotlib.pyplot as plt

pwd

#Read in raw data

fname = 'oddball_example_small-fif'

raw = mne.io.read_raw_fif(fname)

# helper information
dir(raw)

# helper information
raw.crop?

raw.filter?

# by default, MNE does not store raw and epochs objects in memory

raw = mne.io.read_raw_fif(fname, preload = True)

raw.filter(1, 20)

raw.plot();



# there are many eog arefacts. We will use ICA to correct. Create ICA object and use its .fit method















ica = mne.preprocessing.ICA(n_components = 20, random_state = 42)

ica.fit(raw.copy().filter(8, 35))

ica.plot_components(outlines = 'skirt');

# store the 'bad' components in the ica object

ica.exclude = [1, 10, 14, 17, 18, 19]

bad_idx, scores = ica.find_bads_eog(raw, 'SO2', threshold = 2)
print(bad_idx)

# compare raw and adjusted data

raw.plot();

ica.apply(raw.copy(), exclude = ica.exclude).plot();

# epochs

# for epoching the data, we need event markers, usually, these are stored in the raw object, in mne, in a stimulus channel

events = mne.find_events(raw)

# events is an array*time in sampes, zero, trigger)

events

mne.viz.plot_events(events[:100]);

# for creating an mne.Epochs object, we require a dictionary of the intended condition names and the corresponding trigger numbers

event_ids = {'standard/stimulus': 200, 'target/stimulus': 100}

epochs = mne.Epochs(raw, events, event_id = event_ids)

epochs.plot();

epochs = ica.apply(epochs.load_data(), exclude = ica.exclude)

epochs.apply_baseline((None, 0))

# how does the epoched avtivity looks like?



epochs.info

epochs['target'].plot_image(picks = [13])

epochs['stimulus'].plot_image(picks = [13])

epochs['target'].plot_image(picks = [7])

# to ensure we have as many Oddball as standard trails, we can run...

epochs.equalize_event_counts(event_ids)

# standard = target

# write the epochs to disk

epochs.save('oddball-epo.fif')   # cleared bad ic

X = epochs.get_data()

X.shape

type(X)

epochs['target'].get_data().shape





# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import mne
import matplotlib.pyplot as plt

fname = 'oddball-epo.fif'
epochs = mne.read_epochs(fname)

epochs.get_data()

epochs

# Evoked

# # finnaly, if we average an epoched dataset over trials, we can use the mne.evoked object

target = epochs['target'].average()
target

standard = epochs['standard'].average()
standard

epochs.get_data().shape   # all data inlcudes standards and target

epochs['target'].get_data().shape  #

# average target

target.data.shape

target.info

dir(target)

target.plot_image();

target.plot();  # Average ERP FROM 106 trails,

target.plot_topomap();

target.plot_topomap(times = [0.1, 0.2, 0.3, 0.4, 0.5]);  # specific times lines

target.plot_joint(times = [0.1, 0.2, 0.3, 0.4, 0.5]);   # target plot + topomap

# for condition contrasts, use mne.comibne.evoked

diff = mne.combine_evoked((target, -standard), weights ='equal')
diff.plot_joint(times = .35);

# 10/20 electrode layout, we can use nicer layerout

rois = mne.channels.make_1020_channel_selections(diff.info, midline = 'z12')

rois  # lef, midline, right channels

diff.plot_image(group_by = rois, show = False, show_names = 'all')

# mne.viz.plot_compareevoked to contrast multiple conditions
def custom_func(x):
    return x.max(axis=1)


for combine in ('mean', 'median', 'gfp', custom_func):
    mne.viz.plot_compare_evokeds({'standard': standard,
                            'target': target}, picks=[13], combine=combine);

# Visualize all target data

target.plot_sensors(show_names = True);

target.data

x = target.data

ch_names = target.info['ch_names']
ch_names

channel = 'C4'
chIndex = [i for i, j in enumerate(ch_names) if j == channel]

plt.plot(x[chIndex[0], :])
plt.title(channel)
plt.ylabel('amplitude')
plt.xlabel('time ')
plt.show();

# visualize all channel
plt.plot(x.T)
plt.title('all channel')
plt.ylabel('amplitude')
plt.xlabel('time ')
plt.show();

"""## Time-Frequency topic




"""

epochs_for_tfr = mne.read_epochs('oddball-epo.fif')

epochs_for_tfr.info

epochs_for_tfr.plot_psd(fmin = 0, fmax = 40);   # hz

# correlation between time/frequency and oddball effect
# extract power per time and frequency with morlet wavelets

from mne.time_frequency import tfr_morlet  # decompose time and frequency

freqs = list(range(8, 30))

tfr_target = tfr_morlet(epochs_for_tfr['target'], freqs, 3, return_itc = False) 
tfr_standard = tfr_morlet(epochs_for_tfr['standard'], freqs, 3, return_itc = False)

tfr_target.data.shape

# time-frequency data is stored in tfr, behave like evoked

tfr_contrast = mne.combine_evoked((tfr_standard, tfr_target), (-5, .5))

tfr_contrast.apply_baseline((None, 0))

# plot time-freuqncy activity(event-related specitral perturbations):: observe the alpha-band ERD and the time-frequency corerlation of the P3 effect

tfr_contrast.plot_joint();

tfr_contrast.plot(picks=[13])